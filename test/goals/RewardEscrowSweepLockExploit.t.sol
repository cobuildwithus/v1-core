// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.34;

import { GoalRevnetFixtureBase } from "test/goals/helpers/GoalRevnetFixtureBase.t.sol";

import { IGoalTreasury } from "src/interfaces/IGoalTreasury.sol";
import { IRewardEscrow } from "src/interfaces/IRewardEscrow.sol";

contract RewardEscrowSweepLockExploitTest is GoalRevnetFixtureBase {
    int96 internal constant INCOMING_FLOW_RATE = 1_000_000; // wei per second

    address internal alice = address(0xB0B);
    address internal attacker = address(0xA77AC);

    function setUp() public override {
        super.setUp();

        _setUpGoalIntegration(_goalConfigPresetWithEscrow());
        _mintAndApproveStakeTokens(alice, 1_000e18, 1_000e18);

        _stakeCobuild(alice, 100e18);
        _activateWithIncomingFlowAndHookFunding(100e18, other, INCOMING_FLOW_RATE);
        vm.warp(block.timestamp + 1 days);
    }

    function test_permissionlessExpiryCannotLockEscrowRewards_whenAnyoneForwardsSweep() public {
        uint256 preFinalizeEscrowSuperTokenBalance = superToken.balanceOf(address(rewardEscrow));
        assertGt(preFinalizeEscrowSuperTokenBalance, 0);

        vm.warp(treasury.deadline() + 1);

        // Any account can finalize to Expired once the deadline passes.
        vm.prank(attacker);
        treasury.sync();

        assertEq(uint256(treasury.state()), uint256(IGoalTreasury.GoalState.Expired));
        assertEq(rewardEscrow.finalState(), uint8(IGoalTreasury.GoalState.Expired));

        uint256 snapshot = rewardEscrow.rewardPoolSnapshot();
        assertGt(snapshot, 0);
        assertGe(snapshot, preFinalizeEscrowSuperTokenBalance);
        assertEq(superToken.balanceOf(address(rewardEscrow)), 0);

        // Externally-owned accounts cannot sweep failed/expired rewards.
        vm.prank(attacker);
        vm.expectRevert(IRewardEscrow.ONLY_GOAL_TREASURY.selector);
        rewardEscrow.releaseFailedAssetsToTreasury();

        vm.prank(owner);
        vm.expectRevert(IRewardEscrow.ONLY_GOAL_TREASURY.selector);
        rewardEscrow.releaseFailedAssetsToTreasury();

        // Any caller can forward sweep through GoalTreasury to release rewards.
        uint256 treasuryGoalBefore = goalToken.balanceOf(address(treasury));
        vm.prank(attacker);
        uint256 swept = treasury.sweepFailedAndBurn();
        assertEq(swept, snapshot);
        assertEq(goalToken.balanceOf(address(rewardEscrow)), 0);
        assertEq(goalToken.balanceOf(address(treasury)) - treasuryGoalBefore, swept);
    }

    function test_successWithZeroSnapshotPoints_cannotPermanentlyLockEscrowRewards_whenAnyoneForwardsSweep() public {
        uint256 preFinalizeEscrowSuperTokenBalance = superToken.balanceOf(address(rewardEscrow));
        assertGt(preFinalizeEscrowSuperTokenBalance, 0);

        // No tracked budgets resolved as succeeded -> success snapshot points stay zero.
        _resolveGoalSuccessViaAssertion();

        assertEq(uint256(treasury.state()), uint256(IGoalTreasury.GoalState.Succeeded));
        assertEq(rewardEscrow.finalState(), uint8(IGoalTreasury.GoalState.Succeeded));
        assertEq(rewardEscrow.totalPointsSnapshot(), 0);

        uint256 snapshot = rewardEscrow.rewardPoolSnapshot();
        assertGt(snapshot, 0);
        assertGe(snapshot, preFinalizeEscrowSuperTokenBalance);
        assertEq(superToken.balanceOf(address(rewardEscrow)), 0);

        // Users cannot claim from a zero-point success snapshot.
        uint256 attackerGoalBefore = goalToken.balanceOf(attacker);
        vm.prank(attacker);
        (uint256 claimAmount, ) = rewardEscrow.claim(attacker);
        assertEq(claimAmount, 0);
        assertEq(goalToken.balanceOf(attacker), attackerGoalBefore);

        // Externally-owned accounts cannot sweep directly.
        vm.prank(attacker);
        vm.expectRevert(IRewardEscrow.ONLY_GOAL_TREASURY.selector);
        rewardEscrow.releaseFailedAssetsToTreasury();

        vm.prank(owner);
        vm.expectRevert(IRewardEscrow.ONLY_GOAL_TREASURY.selector);
        rewardEscrow.releaseFailedAssetsToTreasury();

        // Any caller can forward sweep even in succeeded+zero-points mode.
        uint256 treasuryGoalBefore = goalToken.balanceOf(address(treasury));
        vm.prank(attacker);
        uint256 swept = treasury.sweepFailedAndBurn();
        assertEq(swept, snapshot);
        assertEq(goalToken.balanceOf(address(rewardEscrow)), 0);
        assertEq(goalToken.balanceOf(address(treasury)) - treasuryGoalBefore, swept);
    }
}
